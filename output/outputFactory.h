/// \file outputFactory.h
/// Defines the gemc output Factory .\n
/// It contains the factory method
/// that returns a pointer to goutputs.\n
/// The virtual method processOutput writes events to
/// the correct stream.\n
/// \author \n Maurizio Ungaro
/// \author mail: ungaro@jlab.org\n\n\n
#ifndef OUTPUT_FACTORY_H
#define OUTPUT_FACTORY_H 1

// gemc
#include "gbank.h"
#include "options.h"
#include "MPrimaryGeneratorAction.h"

// mlibrary
#include "frequencySyncSignal.h"

// EVIO
#include "evioUtil.hxx"
#include "evioFileChannel.hxx"
using namespace evio;

// geant4
#include "G4ThreeVector.hh"


/// \class hitOutput
/// <b> hitOutput</b>\n\n
/// Contains dynamic output informations
/// - geant4 information, summed over the hit: vector<double> raws
/// - digitized information, from g4 summed: vector<int> dgtz
// This information is relevant to ONE hit only

// TODO: all these quantities should be references.


class hitOutput
{
private:

	// geant4 integrated (over the hit) information.
	// DISABLED by default
	// key is variable name
	map<string, double> raws;

	// digitized information coming from raws
	// ENABLED by default
	// key is variable name
	map<string, double> dgtz;

	// geant4 step by step information.
	// DISABLED by default
	// key is variable name
	map< string, vector <double> > allRaws;

	// multi - digitized information from step by step
	// DISABLED by default
	// key is variable name
	map< string, vector <int> >  multiDgt;

	// quantized signal as a function of time bunch
	// DISABLED by default
	// the first three entries are crate/slot/channel
	map< int, int >  quantumS;

	// charge ([0]), time([1] info at every step
	// DISABLED by default
	// index 0: hit number
	// index 1: step index
	// index 2: charge at electronics
	// index 3: time at electronics
	// index 4: vector of identifiers - have to match the translation table
	// index 5: hardware - it's a vector[3] with crate/slot/channel
	map< int, vector <double> >  chargeTime;

public:

	void setRaws       (map<string, double> r)            {raws = r;}
	void setDgtz       (map<string, double> d)            {dgtz = d;}
	void setAllRaws    (map< string, vector <double> > r) {allRaws  = r;}
	void setMultiDgt   (map< string, vector <int> > d)    {multiDgt = d;}
	void setChargeTime (map< int, vector <double> > d)    {chargeTime = d;}

	void setOneRaw    (string s, double d)              {raws[s] = d;}
	void setOneRaw    (string s, int i)                 {raws[s] = (double) i;}

	void setOneDgt    (string s, double d)              {dgtz[s] = d;}
	void setOneDgt    (string s, int i)                 {dgtz[s] = (double) i;}

	void createQuantumS(map< int, int > qs) {quantumS = qs;}


	// may want to insert verbosity here?
	map<string, double>            getRaws()       {return raws;}
	map<string, double>            getDgtz()       {return dgtz;}
	map< string, vector <double> > getAllRaws()    {return allRaws;}
	map< string, vector <int> >    getMultiDgt()   {return multiDgt;}
	map< int, vector <double> >    getChargeTime() {return chargeTime;}
	map< int, int >         	   getQuantumS()   {return quantumS;}

	double getIntRawVar(string s)
	{
		if(raws.find(s) != raws.end()) return raws[s];
		return -99;
	}
	double getIntDgtVar(string s)
	{
		if(dgtz.find(s) != dgtz.end()) return dgtz[s];
		return -99;
	}
};



/// \class summaryForParticle
/// <b> summaryForParticle </b>\n\n
/// Contains a summary information for each detector, caused
/// by a primary particle and all its descendant
/// - stat (how many hits generated by this track)
/// - total energy
/// - fastest time
/// - nphe
/// - detector name
class summaryForParticle
{
public:
	summaryForParticle(string detector)
	{
		dname = detector;
		stat  = 0;
		etot  = 0;
		t     = -1;  // initializing to negative for the first assignment
		nphe  = 0;
	}
	~summaryForParticle(){;}

	string dname;
	int    stat;
	double etot;
	double t;
	int    nphe;

};


/// \class fastMCForParticle
/// <b> fastMCForParticle </b>\n\n
/// Contains fastMC information for each detector, caused
/// by a primary particle
/// - original track momentum
/// - smeared track momentum
class fastMCForParticle
{
public:
	fastMCForParticle(string detector)
	{
		pOrig  = G4ThreeVector(0,0,0);
		pSmear = G4ThreeVector(0,0,0);
	}
	~fastMCForParticle(){;}

	/// - stat (how many hits generated by this track)
	G4ThreeVector pOrig;
	G4ThreeVector pSmear;

};




/// \class generatedParticle
/// <b> generatedParticle </b>\n\n
/// Contains particle informations.
/// The Primary Particles will be written to the output.\n
/// Secondary Particles will be written to the output if option is specified.\n
class generatedParticle
{
public:
	generatedParticle()
	{
		pSum.clear();
		fastMC.clear();
	}
	~generatedParticle(){;}

	G4ThreeVector vertex;
	G4ThreeVector momentum;
	int PID;
	double time;
	int multiplicity;

	// adding summary information for each detector.
	vector<summaryForParticle>   pSum;
	vector<fastMCForParticle>    fastMC;


	int    getVariableFromStringI(string);
	double getVariableFromStringD(string);
};




/// \class outputContainer
/// <b> outputContainer </b>\n\n
/// Contains all possible outputs.
class outputContainer
{
public:
	outputContainer(goptions);
	~outputContainer();

	goptions gemcOpt;
	string outType;
	string outFile;

	ofstream        *txtoutput;
	evioFileChannel *pchan;
};

/// \class outputFactory
/// <b> outputFactory </b>\n\n
/// outputFactory is registered in a map<string, outputFactory>\n
/// The virtual method processOutput is called at the end of each event.

class outputFactory
{
public:

	// record the simulation conditions on the file
	virtual void recordSimConditions(outputContainer*, map<string, string>) = 0;

	// write event header
	virtual void writeHeader(outputContainer*, map<string, double>, gBank)  = 0;

	// write RF Signal
	virtual void writeRFSignal(outputContainer*, FrequencySyncSignal, gBank)  = 0;

	// write generated particles
	virtual void writeGenerated(outputContainer*, vector<generatedParticle>, map<string, gBank> *banksMap, vector<userInforForParticle> userInfo) = 0;

	// write geant4 true integrated info
	virtual void writeG4RawIntegrated(outputContainer*, vector<hitOutput>, string, map<string, gBank>*) = 0;

	// write geant4 true info for every step
	virtual void writeG4RawAll(outputContainer*, vector<hitOutput>, string, map<string, gBank>*) = 0;

	// write geant4 raw integrated info
	virtual void writeG4DgtIntegrated(outputContainer*, vector<hitOutput>, string, map<string, gBank>*) = 0;

	// write geant4 charge / time (as seen by electronic) info
	virtual void writeChargeTime(outputContainer*, vector<hitOutput>, string, map<string, gBank>*) = 0;

	// write fadc mode 1 (full signal shape) - jlab hybrid banks. This uses the translation table to write the crate/slot/channel
	virtual void writeFADCMode1(outputContainer*, vector<hitOutput>, int) = 0;

        // write fadc mode 1 (full signal shape) - jlab hybrid banks. This uses the translation table to write the crate/slot/channel
        // This method should be called once at the end of event action, and the 1st argument 
        // is a map<int crate_id, vector<hitoutput> (vector of all hits from that crate) >
	virtual void writeFADCMode1( map<int, vector<hitOutput> >, int)  = 0;
        
	// write fadc mode 7 (integrated mode) - jlab hybrid banks. This uses the translation table to write the crate/slot/channel
	virtual void writeFADCMode7(outputContainer*, vector<hitOutput>, int) = 0;

	// write event and close stream if necessary
	virtual void writeEvent(outputContainer*) = 0;

	string outputType;

	virtual ~outputFactory(){;}
};

// Define outputFactory as a pointer to a function that returns a pointer to a outputFactory
typedef outputFactory *(*outputFactoryInMap)();

// Instantiates the outputFactory
outputFactory *getOutputFactory(map<string, outputFactoryInMap>*, string);

map<string, outputFactoryInMap> registerOutputFactories();


#endif
